************ SET-1 *************************
1.  c. ACID Compilance
2.  b. False
3.  a. True
4.  b. A amster node determine who gets what data
5.  a. Available and partition tolerant
6.  a. True
7.  a. When creating a keyspace
8.  a. True
9.  c. Both read and write requests
10. b. False
11. a. On a per-query basis

****************** SET-2 **************************
1.  a. True
2.  b. Coordinator node
3.  b. Commit log to Memtable to SStable
4.  a. True
5.  b. False
6.  a. Taking small SSTables and merges them into bigger ones
7.  b. Timestamps
8.  d. All of the above
9.  e. All of the above
10. a. True

*************** SET-3 ***************************
1. d. group rows physically together on disk based on the partition key.
2. b. It hashes the partition key values to create a partition token.
3. b. False
4. b. False
5. b. False
6. a. Reading sorted data is a matter of seeking the disk head once.
7. b. False
8. a. 2-4 Terabytes
9. b. False
10. b. 128
11. a. num_tokens
12. b. False
13. b. False
14. d. All of the above
15. c. Determine/declare each node's rack and data center.
16. a. True
17. d. CassandraSnitch
18. b. False
19. d. All of the above.
20. b. availability/partition tolerance
21. b. 2
22. e. All of the above
23. b. 3 hours
24. b. False
25. d. ALL
26. b. Sets the probability which Cassandra will perform a read repair with a consistency level less than ALL.
27. b. to replay if a crashed node restarts.
28. d. After the commit log and MemTable are written
29. b. SSTable, d. Memtable
30. c. stores byte offsets into the partition index.
31. a. stores the byte offset of the most recently accessed records.
32. b. SSTable, d. Partition Index
33. a. More optimal disk usage, b. Faster reads, d. Less memory pressure
34. b. false
35. d. The input partition segments are made up of mostly INSERT operations.
